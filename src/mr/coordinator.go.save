package mr

import "log"
import "net"
import "os"
import "net/rpc"
import "net/http"
import "sync/atomic"
import "fmt"

// 添加全局变量存储files
var globalFiles []string
var globalRegisteredWorkerNum int32 = 0
var globalfilesNum =0

// var globalRegisteredWorkers[] int

type TaskStatus int

const (
	MapTaskStatus_Idle TaskStatus = iota
	MapTaskStatus_Running
	MapTaskStatus_Finished
	MapTaskStatus_failed
)

const (
	ReduceTaskStatus_Idle TaskStatus = iota
	ReduceTaskStatus_Running
	ReduceTaskStatus_Finished
	ReduceTaskStatus_failed
)

type Coordinator struct {
	// Your definitions here.

	// map task
	mapTask []MapTask
	mapTaskNum int
	reduceTask []ReduceTask
	reduceTaskNum int

	//原子类型
	remainMapTaskNum int32 
	remainReduceTaskNum int32
	
}

type MapTask struct {
	FileName string
	TaskId int
	Status TaskStatus
}

type ReduceTask struct {
	FileName string
	TaskId int
	Status TaskStatus
}
type WorkerInfo struct {
	WorkerId int
	//是否可用
	Status bool
}

// Your code here -- RPC handlers for the worker to call.

//
// an example RPC handler.
//
// the RPC argument and reply types are defined in rpc.go.
//
func (c *Coordinator) Example(args *ExampleArgs, reply *ExampleReply) error {
	reply.Y = args.X + 1
	return nil
}

//返回任务
func (c *Coordinator) WorkerRequestTask(args *RequestTaskArgs, reply *[]WorkerRequestTask) error { 
	//打印参数
	// fmt.Printf("workerRequestTask() args: %v\n", args)
	// fmt.Printf("files: %v\n", globalFiles)
	//将任务分配给worker，即将所有的files随机分配给worker,globalFiles为文件列表，1-globalRegisteredWorkerNum为所有worker的id
	for i := 0; i < len(globalFiles); i++ { 
		
		//文件总数对worker数量取模，获得所有这个worker的files
		if i % int(globalRegisteredWorkerNum) == (args.WorkerId-1) {
			workerRequestTask:=WorkerRequestTask{}
			workerRequestTask.FileName = globalFiles[i]
			workerRequestTask.TaskId = i
			workerRequestTask.TaskType = "map"
			//更改c.mapTasks中的对应task的状态
			c.mapTask[i] = MapTask{FileName: globalFiles[i], Status: MapTaskStatus_Running, TaskId: i}
			c.freeWorkers[args.WorkerId]=false
			*reply = append(*reply, workerRequestTask)
		}
	}
	return nil;
}

func (c *Coordinator) Register(args *RegistArgs, reply *RegistReply) error { 
	//统计worker数量：如果有心跳请求rpc，则将coordiantor的gloabalworkernum++

	atomic.AddInt32(&globalRegisteredWorkerNum, 1)
	reply.OK = true
	reply.WorkerId = int(atomic.LoadInt32(&globalRegisteredWorkerNum))
	//freeworker变成map形式 worker1：true or false ,全局变量
	c.freeWorkers[reply.WorkerId] = true
	fmt.Println("globalRegisteredWorkerNum:", atomic.LoadInt32(&globalRegisteredWorkerNum))
	return nil;

}

func (c 





*Coordinator) GetStatusFromWorker(args *ReportTaskDoneArgs, reply *ReportTaskDoneReply) error { 
	//获取worker状态
	TaskId := args.TaskId
	switch args.TaskType {
	case "map":
		c.mapTask[TaskId].Status = MapTaskStatus_Finished
		c.freeWorkers[args.WorkerId]=true
		atomic.AddInt32(&c.remainMapTaskNum, -1)
	case "reduce":
		c.reduceTask[TaskId].Status =ReduceTaskStatus_Finished
		c.freeWorkers[args.WorkerId]=true
		atomic.AddInt32(&c.remainReduceTaskNum, -1)
	}
	reply.OK=true
	return nil;
}



//
// start a thread that listens for RPCs from worker.go
//
func (c *Coordinator) server() {
	rpc.Register(c)
	rpc.HandleHTTP()
	//l, e := net.Listen("tcp", ":1234")
	sockname := coordinatorSock()
	os.Remove(sockname)
	l, e := net.Listen("unix", sockname)
	if e != nil {
		log.Fatal("listen error:", e)
	}
	go http.Serve(l, nil)
}

//
// main/mrcoordinator.go calls Done() periodically to find out
// if the entire job has finished.
//
func (c *Coordinator) Done() bool {
	ret := false
	// 需要两个状态，map任务结束，reduce任务结束，
	// 即map结束任务数量等于map任务数量，reduce结束任务数量等于reduce任务数量
	//原子检查remainMapTasknum和remainReduceTasknum是否都为零，如果都为零则返回true
	//否则返回false
	ret = atomic.CompareAndSwapInt32(&c.remainMapTaskNum, 0, 0) && atomic.CompareAndSwapInt32(&c.remainReduceTaskNum, 0, 0)
	return ret
}

//
// create a Coordinator.
// main/mrcoordinator.go calls this function.
// nReduce is the number of reduce tasks to use.
//
func MakeCoordinator(files []string, nReduce int) *Coordinator {
	globalFiles=files
	globalfilesNum:=len(files)
	fmt.Println("filesNum:",globalfilesNum)
	c := Coordinator{}
	freeWorkers := make(map[int]bool)


	// 初始化任务分片数目，初始化剩余map数、map任务状态、
	// 剩余reduce数、reduce任务状态
	c.mapTaskNum = len(files)
	c.reduceTaskNum=nReduce
	c.remainMapTaskNum=int32(len(files))
	c.remainReduceTaskNum=int32(nReduce)
	c.mapTask = make([]MapTask,len(files))
	c.reduceTask = make([]ReduceTask,nReduce)

	for i:=0;i<len(files);i++{
		c.mapTask[i].FileName=files[i]
		c.mapTask[i].TaskId=i
		c.mapTask[i].Status=MapTaskStatus_Idle
		fmt.Printf("%v",c.mapTask[i])

	}
	
	for i:=0;i<nReduce;i++{
		c.reduceTask[i].FileName=""
		c.reduceTask[i].TaskId=i
		c.reduceTask[i].Status=ReduceTaskStatus_Idle
	}
	


	c.server()
	return &c
}
